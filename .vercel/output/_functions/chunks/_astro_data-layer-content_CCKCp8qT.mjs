const _astro_dataLayerContent = [["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.1","content-config-digest","63d7f300aa653daf","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false}}","post",["Map",11,12,204,205,264,265],"test",{id:11,data:13,body:17,filePath:18,digest:19,rendered:20,legacyId:203},{title:14,description:15,dateFormatted:16},"Mastering Docker for DevOps: From Zero to Advanced","Everything you need to know about docker","January 2, 2025","In today’s fast-paced DevOps world, <strong>Docker</strong> has revolutionized how we develop, test, and deploy applications. It provides a standardized way to run software, ensuring that applications behave the same in development as they do in production. If you're new to Docker or looking to deepen your knowledge, this guide will take you from the basics to advanced Docker concepts.\n\n\nBy the end of this article, you'll have a deep understanding of Docker, how to use it in real-world DevOps scenarios, and practical experience with key Docker commands. Whether you're setting up a simple web server or managing multi-container applications, you'll have all the tools and knowledge to do so confidently.\n\n\n---\n\n\n### <strong>Table of Contents</strong>\n\n1. What is Docker?\n2. Why Docker for DevOps?\n3. Docker vs. Virtual Machines\n4. Types of Docker\n\t- Docker Desktop\n\t- Docker Swarm\n5. Installing Docker\n6. Docker Images and Containers\n\t- How to Pull Docker Images\n\t- Working with Containers\n7. Dockerfiles: Building Your Own Docker Image\n\t- Writing a Dockerfile\n\t- Steps in a Dockerfile\n8. Docker Networking\n9. Docker Volumes: Persistent Storage\n10. Docker Compose\n11. Docker Swarm: Orchestration Simplified\n12. Alternatives to Docker\n13. Real-World Use Cases for Docker in DevOps\n14. Complete List of Docker Commands (With Examples and Flags)\n\n---\n\n\n### <strong>1. What is Docker?</strong>\n\n\n<strong>Docker</strong> is an open-source platform that helps developers and DevOps engineers <strong>build, ship, and run applications inside containers</strong>. A container is a lightweight, portable, and isolated environment that contains everything an application needs to run—such as code, runtime, libraries, and dependencies—allowing it to work consistently across different environments (development, staging, production).\n\n\n### Why Containers?\n\n- <strong>Portability</strong>: Docker ensures that an application runs the same, no matter where it’s deployed.\n- <strong>Efficiency</strong>: Containers are lightweight and share the host OS’s kernel, making them faster and more efficient than traditional virtual machines (VMs).\n- <strong>Scalability</strong>: Containers can be scaled easily to handle more traffic, making them ideal for microservices architecture and cloud-native applications.\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the key advantage of Docker containers in terms of application portability?</strong></summary>\n\n- A) They run different versions of the same application simultaneously.\n\n- B) They ensure the application runs consistently across different environments.\n\n- C) They allow users to run multiple operating systems at once.\n\n_(Answer : C)_\n\n\n</details>\n\n\n---\n\n\n### <strong>2. Why Docker for DevOps?</strong>\n\n\nIn DevOps, speed, automation, and consistency are critical for achieving continuous integration (CI) and continuous delivery (CD). Docker offers several benefits:\n\n- <strong>Isolation</strong>: Each container runs independently, which prevents conflicts between applications.\n- <strong>Rapid Deployment</strong>: Docker containers start up quickly, making deployment faster than with virtual machines.\n- <strong>Consistency</strong>: Docker ensures that your applications work the same across different environments (dev, staging, production), minimizing the “works on my machine” issue.\n\nBy using Docker, DevOps teams can streamline workflows, automate processes, and increase development speed.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>How does Docker enhance the speed of deployments in DevOps?</strong></summary>\n\n- A) Containers boot faster than virtual machines.\n\n- B) Docker uses virtual machines for faster deployment.\n\n- C) Docker deploys applications without using an OS kernel.\n\n_(Answer: A)_\n\n\n</details>\n\n\n---\n\n\n### <strong>3. Docker vs. Virtual Machines</strong>\n\n\nWhile Docker and virtual machines both help in running applications in isolated environments, they have key differences.\n\n\n| <strong>Docker (Containers)</strong>             | <strong>Virtual Machines</strong>                      |\n| ----------------------------------- | ----------------------------------------- |\n| Uses containers to run apps         | Uses virtual machines with a full OS      |\n| Shares host OS kernel (lightweight) | Each VM has its own OS (heavier)          |\n| Starts in seconds                   | Takes minutes to boot                     |\n| Efficient resource usage            | More resource-intensive                   |\n| Ideal for microservices and CI/CD   | Good for running multiple OS environments |\n\n\n![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b557715-1f08-43ae-ac1a-b814d80e7850/d829c88a-4fae-47a5-b9d7-3c298696d73c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20250104%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250104T041405Z&X-Amz-Expires=3600&X-Amz-Signature=567e7bbccb7207f55009c97ef28cfc31e112216e5d12b8f901dc2e7e0f6651e7&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b557715-1f08-43ae-ac1a-b814d80e7850/cc6f4ac1-e9d5-4455-950b-9b3c5022b292/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20250104%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250104T041405Z&X-Amz-Expires=3600&X-Amz-Signature=48e2841d1f58183c312f22b1825083a9e35d39b469b31eeb13a7476adb51175b&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>Why are Docker containers considered more lightweight than virtual machines?</strong></summary>\n\n- A) Containers share the host OS’s kernel.\n\n- B) Containers include their own full operating systems.\n\n- C) Containers can only run one service at a time.\n\n_(Answer: A)_\n\n\n</details>\n\n\n---\n\n\n### <strong>4. Docker and it’s form</strong>\n\n\n### <strong>Docker Desktop</strong>\n\n\n<strong>Docker Desktop</strong> is an application that provides a local development environment for building, running, and testing Docker containers. It's available for <strong>Windows</strong>, <strong>macOS</strong>, and <strong>Linux</strong>. Docker Desktop is perfect for developers who need a simple setup to get started with Docker.\n\n\n### <strong>Docker Swarm</strong>\n\n\n<strong>Docker Swarm</strong> is Docker’s native orchestration tool. It allows you to manage and scale a cluster of Docker containers across multiple hosts. Swarm provides features like load balancing, service discovery, and scaling with minimal configuration.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the purpose of Docker Swarm?</strong></summary>\n\n- A) To manage a single container on one host.\n\n- B) To orchestrate containers across multiple hosts.\n\n- C) To create virtual machines for testing purposes.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>5. Installing Docker</strong>\n\n\nInstalling Docker is straightforward and varies slightly depending on your operating system. Here’s how to install Docker on Ubuntu:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">sudo apt update\nsudo apt install docker.io\nsudo systemctl start docker\nsudo systemctl enable docker</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\nFor <strong>macOS</strong> and <strong>Windows</strong>, simply download <strong>Docker Desktop</strong> from the official Docker website and follow the installation instructions.\n\n\nVerify that Docker is installed:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker --version</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>How do you verify that Docker has been installed correctly?</strong></summary>\n\n- A) Run <code class=\"inline-code\">docker status</code>\n\n- B) Run <code class=\"inline-code\">docker --version</code>\n\n- C) Run <code class=\"inline-code\">docker start</code>\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>6. Docker Images and Containers</strong>\n\n\n### <strong>What is a Docker Image?</strong>\n\n\nA <strong>Docker image</strong> is a read-only template that contains the instructions to create a container. Images include everything needed to run an application—such as code, libraries, and configurations.\n\n\n### <strong>What is a Docker Container?</strong>\n\n\nA <strong>container</strong> is a running instance of a Docker image. It provides an isolated environment to run your application without interfering with the rest of your system.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the relationship between Docker images and containers?</strong></summary>\n\n- A) An image is a running instance of a container.\n\n- B) A container is a running instance of an image.\n\n- C) A container contains Docker images.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>How to Pull Docker Images</strong>\n\n\nDocker images can be pulled from Docker Hub, a public repository for Docker images.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker pull <image-name></code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Example:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker pull nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\nThis command pulls the latest version of the <strong>nginx</strong> web server image from Docker Hub.\n\n\n### Real-World Scenario:\n\n\nYou're setting up a web server for testing purposes and need to download the NGINX image to create a container.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>Where do you typically pull Docker images from?</strong></summary>\n\n- A) Docker Swarm\n\n- B) Docker Hub\n\n- C) Docker Engine\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>Working with Docker Containers</strong>\n\n\nTo create and run a container from an image:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d -p 80:80 nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Real-World Scenario:\n\n\nThis command runs an NGINX container in <strong>detached mode</strong> (<code class=\"inline-code\">-d</code>) and maps port 80 of the container to port 80 of the host (<code class=\"inline-code\">-p</code>). Now, you can access the NGINX server at <code class=\"inline-code\">http://localhost</code>.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What does the</strong> <strong><code class=\"inline-code\">docker run -d</code></strong> <strong>flag do when running a container?</strong></summary>\n\n- A) Deletes the container after running.\n\n- B) Runs the container in detached mode.\n\n- C) Duplicates the container.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>7. Dockerfiles: Building Your Own Docker Image</strong>\n\n\nA <strong>Dockerfile</strong> is a text file that contains instructions on how to build a Docker image. It specifies the base image, environment variables, dependencies, and application code that will be included in the container.\n\n\n### <strong>Writing a Dockerfile</strong>\n\n\nHere’s an example of a simple <strong>Dockerfile</strong> for a Node.js application:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-text\">\\# Use the official Node.js image as the base image\nFROM node:14\n\n\\# Set the working directory inside the container\nWORKDIR /app\n\n\\# Copy package.json and install dependencies\nCOPY package.json .\nRUN npm install\n\n\\# Copy the rest of the application code\nCOPY . .\n\n\\# Expose the app's port\nEXPOSE 3000\n\n\\# Start the application\nCMD [\"npm\", \"start\"]</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>Steps in a Dockerfile</strong>:\n\n1. <strong>FROM</strong>: Specifies the base image (in this case, <code class=\"inline-code\">node:14</code>).\n2. <strong>WORKDIR</strong>: Sets the working directory inside the container.\n3. <strong>COPY</strong>: Copies files from your local machine to the container.\n4. <strong>RUN</strong>: Runs a command (e.g., <code class=\"inline-code\">npm install</code>) inside the container.\n5. <strong>EXPOSE</strong>: Opens a port (3000 in this case) to allow communication with the container.\n6. <strong>CMD</strong>: Specifies the command that will run when the container starts.\n\n### Building a Docker Image:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker build -t myapp:latest .</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\nThis command builds the Docker image from the Dockerfile in the current directory and tags it as <code class=\"inline-code\">myapp:latest</code>.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the purpose of the</strong> <strong><code class=\"inline-code\">FROM</code></strong> <strong>instruction in a Dockerfile?</strong></summary>\n\n- A) To create a new directory inside the container.\n\n- B) To specify the base image from which to build the container.\n\n- C) To run commands inside the container.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>8. Docker Networking</strong>\n\n\n<strong>Docker Networking</strong> enables communication between containers and the outside world or between containers in a cluster. Docker automatically sets up a <strong>bridge network</strong> for containers by default.\n\n\n### Creating a Custom Network:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker network create my-network</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\nYou can attach containers to this network:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d --name web --network my-network nginx\ndocker run -d --name db --network my-network postgres</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Real-World Scenario:\n\n\nYou’re building a multi-tier application where a <strong>web container</strong> (NGINX) and a <strong>database container</strong> (Postgres) need to communicate. By attaching them to the same network (<code class=\"inline-code\">my-network</code>), they can communicate using their container names as hostnames.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>Why would you create a custom Docker network?</strong></summary>\n\n- A) To increase container resource usage.\n\n- B) To enable containers to communicate with each other.\n\n- C) To isolate containers from one another.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>9. Docker Volumes: Persistent Storage</strong>\n\n\nDocker containers are typically <strong>stateless</strong>, meaning any data generated inside the container is lost when the container stops. <strong>Volumes</strong> provide a way to persist data by storing it outside the container.\n\n\n### Creating a Volume:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker volume create my-volume</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Attaching a Volume to a Container:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d -v my-volume:/app/data nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Real-World Scenario:\n\n\nYou need to persist data (such as logs or database files) generated by an application inside the container. Using volumes, you ensure that the data remains available even if the container is stopped or removed.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the purpose of Docker volumes?</strong></summary>\n\n- A) To increase the CPU usage of containers.\n\n- B) To persist data beyond the lifecycle of a container.\n\n- C) To automatically replicate data between containers.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>10. Docker Compose</strong>\n\n\n<strong>Docker Compose</strong> simplifies multi-container deployments. You define your services in a <code class=\"inline-code\">docker-compose.yml</code> file, and Docker Compose brings them up with a single command.\n\n\n### Example <code class=\"inline-code\">docker-compose.yml</code>:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-yaml\">version: '3'\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"80:80\"\n  db:\n    image: postgres\n    environment:\n      POSTGRES_PASSWORD: example\n\nvolumes:\n  db-data:</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Starting the Application:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker-compose up -d</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Real-World Scenario:\n\n\nYou’re deploying an NGINX web server and a Postgres database as part of a development environment. Instead of running multiple <code class=\"inline-code\">docker run</code> commands, you define both services in a <code class=\"inline-code\">docker-compose.yml</code> file and start them with one command.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is the advantage of using Docker Compose?</strong></summary>\n\n- A) It only runs one container at a time.\n\n- B) It allows for multi-container deployments with a single command.\n\n- C) It increases the memory usage of containers.\n\n_(Answer: B)_\n\n\n</details>\n\n\n---\n\n\n### <strong>11. Docker Swarm: Orchestration Simplified</strong>\n\n\n<strong>Docker Swarm</strong> is Docker’s native solution for orchestrating containers across multiple hosts. It simplifies tasks such as load balancing, service discovery, and scaling.\n\n\n### Initializing a Docker Swarm:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker swarm init</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Adding Worker Nodes:\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker swarm join --token <worker-token> <manager-ip></code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### Real-World Scenario:\n\n\nYou want to deploy a scalable application across multiple hosts. Using Docker Swarm, you can create a cluster of machines (nodes) that run containers. Docker Swarm will handle load balancing and service scaling for you.\n\n\n### <strong>Quiz for You!</strong>\n\n<details>\n<summary><strong>What is Docker Swarm used for?</strong></summary>\n\n- A) Managing and scaling containers across multiple hosts.\n\n- B) Running containers on a single machine only.\n\n- C) Replacing Docker Compose.\n\n_(Answer: A)_\n\n\n</details>\n\n\n---\n\n\n### <strong>12. Alternatives to Docker</strong>\n\n\nWhile Docker is the most widely adopted container platform, there are alternatives worth noting:\n\n- <strong>Podman</strong>: A daemonless container engine that’s compatible with Docker commands.\n- <strong>Kubernetes</strong>: A powerful orchestration tool for managing containers at scale, often used with Docker for large, complex deployments.\n- <strong>LXC/LXD</strong>: Linux container technologies that provide full system containers for running multiple Linux distributions.\n\n---\n\n\n### <strong>13. Real-World Use Cases for Docker in DevOps</strong>\n\n- <strong>CI/CD Pipelines</strong>: Docker integrates seamlessly with continuous integration and delivery tools like Jenkins, GitLab CI, and CircleCI, ensuring that each build runs in a consistent environment.\n- <strong>Microservices</strong>: Docker makes it easy to deploy microservices, where each service runs in its own container, making scaling and updating services simple.\n- <strong>Testing and Development</strong>: Developers can use Docker to quickly spin up isolated environments for testing new features, without affecting their local machine or other services.\n\n---\n\n\n### <strong>14. Complete List of Docker Commands (With Examples and Flags)</strong>\n\n\nBelow is a comprehensive list of Docker commands, along with real-world examples and explanations of a running container.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker exec -it myweb /bin/bash</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n- <strong>Flags</strong>:\n\t- <strong><code class=\"inline-code\">it</code></strong>: Interactive terminal (connect to the container’s shell).\n\n### <strong>9.</strong> <strong><code class=\"inline-code\">docker build</code></strong>\n\n\n<strong>Definition</strong>: Builds an image from a Dockerfile.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker build -t myapp:latest .</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n- <strong>Flags</strong>:\n\t- <strong><code class=\"inline-code\">t</code></strong>: Tags the image with a name.\n\t- <strong><code class=\"inline-code\">-no-cache</code></strong>: Builds the image without using cache.\n\n### <strong>10.</strong> <strong><code class=\"inline-code\">docker logs</code></strong>\n\n\n<strong>Definition</strong>: Fetches logs from a container.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker logs -f myweb</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n- <strong>Flags</strong>:\n\t- <strong><code class=\"inline-code\">f</code></strong>: Follow logs (like <code class=\"inline-code\">tail -f</code>).\n\t- <strong><code class=\"inline-code\">-since</code></strong>: Show logs since a specific time.\n\n### <strong>11.</strong> <strong><code class=\"inline-code\">docker inspect</code></strong>\n\n\n<strong>Definition</strong>: Shows detailed information about a Docker object.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker inspect myweb</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>12.</strong> <strong><code class=\"inline-code\">docker volume</code></strong>\n\n\n<strong>Definition</strong>: Manages Docker volumes.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker volume create myvolume\ndocker run -d -v myvolume:/app/data nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>13.</strong> <strong><code class=\"inline-code\">docker network</code></strong>\n\n\n<strong>Definition</strong>: Manages Docker networks.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker network create my-network\ndocker run -d --network my-network --name web nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>14.</strong> <strong><code class=\"inline-code\">docker-compose</code></strong>\n\n\n<strong>Definition</strong>: Defines and runs multi-container applications.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker-compose up -d</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n\n### <strong>15.</strong> <strong><code class=\"inline-code\">docker stats</code></strong>\n\n\n<strong>Definition</strong>: Displays real-time resource usage statistics for running containers.\n\n\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker stats</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n\n- <strong>Flags</strong>:\n\t- <strong><code class=\"inline-code\">-no-stream</code></strong>: Shows only the first result and does not update continuously.\n\n---\n\n\n### <strong>Conclusion</strong>\n\n\nDocker is an incredibly powerful tool for DevOps, allowing you to manage application development, testing, and deployment in a consistent and efficient way. From running simple containers to orchestrating multi-container applications using Docker Swarm, Docker provides all the tools you need for modern software delivery.\n\n\nBy mastering the commands and techniques covered in this guide, you'll be well on your way to becoming proficient in Docker and leveraging it to streamline your DevOps workflows.","src/content/post/test.md","172cb1023ba8365b",{html:21,metadata:22},"<p>In today’s fast-paced DevOps world, <strong>Docker</strong> has revolutionized how we develop, test, and deploy applications. It provides a standardized way to run software, ensuring that applications behave the same in development as they do in production. If you’re new to Docker or looking to deepen your knowledge, this guide will take you from the basics to advanced Docker concepts.</p>\n<p>By the end of this article, you’ll have a deep understanding of Docker, how to use it in real-world DevOps scenarios, and practical experience with key Docker commands. Whether you’re setting up a simple web server or managing multi-container applications, you’ll have all the tools and knowledge to do so confidently.</p>\n<hr>\n<h3 id=\"table-of-contents\"><strong>Table of Contents</strong></h3>\n<ol>\n<li>What is Docker?</li>\n<li>Why Docker for DevOps?</li>\n<li>Docker vs. Virtual Machines</li>\n<li>Types of Docker\n<ul>\n<li>Docker Desktop</li>\n<li>Docker Swarm</li>\n</ul>\n</li>\n<li>Installing Docker</li>\n<li>Docker Images and Containers\n<ul>\n<li>How to Pull Docker Images</li>\n<li>Working with Containers</li>\n</ul>\n</li>\n<li>Dockerfiles: Building Your Own Docker Image\n<ul>\n<li>Writing a Dockerfile</li>\n<li>Steps in a Dockerfile</li>\n</ul>\n</li>\n<li>Docker Networking</li>\n<li>Docker Volumes: Persistent Storage</li>\n<li>Docker Compose</li>\n<li>Docker Swarm: Orchestration Simplified</li>\n<li>Alternatives to Docker</li>\n<li>Real-World Use Cases for Docker in DevOps</li>\n<li>Complete List of Docker Commands (With Examples and Flags)</li>\n</ol>\n<hr>\n<h3 id=\"1-what-is-docker\"><strong>1. What is Docker?</strong></h3>\n<p><strong>Docker</strong> is an open-source platform that helps developers and DevOps engineers <strong>build, ship, and run applications inside containers</strong>. A container is a lightweight, portable, and isolated environment that contains everything an application needs to run—such as code, runtime, libraries, and dependencies—allowing it to work consistently across different environments (development, staging, production).</p>\n<h3 id=\"why-containers\">Why Containers?</h3>\n<ul>\n<li><strong>Portability</strong>: Docker ensures that an application runs the same, no matter where it’s deployed.</li>\n<li><strong>Efficiency</strong>: Containers are lightweight and share the host OS’s kernel, making them faster and more efficient than traditional virtual machines (VMs).</li>\n<li><strong>Scalability</strong>: Containers can be scaled easily to handle more traffic, making them ideal for microservices architecture and cloud-native applications.</li>\n</ul>\n<h3 id=\"quiz-for-you\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the key advantage of Docker containers in terms of application portability?</strong></summary>\n<ul>\n<li>\n<p>A) They run different versions of the same application simultaneously.</p>\n</li>\n<li>\n<p>B) They ensure the application runs consistently across different environments.</p>\n</li>\n<li>\n<p>C) They allow users to run multiple operating systems at once.</p>\n</li>\n</ul>\n<p><em>(Answer : C)</em></p>\n</details>\n<hr>\n<h3 id=\"2-why-docker-for-devops\"><strong>2. Why Docker for DevOps?</strong></h3>\n<p>In DevOps, speed, automation, and consistency are critical for achieving continuous integration (CI) and continuous delivery (CD). Docker offers several benefits:</p>\n<ul>\n<li><strong>Isolation</strong>: Each container runs independently, which prevents conflicts between applications.</li>\n<li><strong>Rapid Deployment</strong>: Docker containers start up quickly, making deployment faster than with virtual machines.</li>\n<li><strong>Consistency</strong>: Docker ensures that your applications work the same across different environments (dev, staging, production), minimizing the “works on my machine” issue.</li>\n</ul>\n<p>By using Docker, DevOps teams can streamline workflows, automate processes, and increase development speed.</p>\n<h3 id=\"quiz-for-you-1\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>How does Docker enhance the speed of deployments in DevOps?</strong></summary>\n<ul>\n<li>\n<p>A) Containers boot faster than virtual machines.</p>\n</li>\n<li>\n<p>B) Docker uses virtual machines for faster deployment.</p>\n</li>\n<li>\n<p>C) Docker deploys applications without using an OS kernel.</p>\n</li>\n</ul>\n<p><em>(Answer: A)</em></p>\n</details>\n<hr>\n<h3 id=\"3-docker-vs-virtual-machines\"><strong>3. Docker vs. Virtual Machines</strong></h3>\n<p>While Docker and virtual machines both help in running applications in isolated environments, they have key differences.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>Docker (Containers)</strong></th><th><strong>Virtual Machines</strong></th></tr></thead><tbody><tr><td>Uses containers to run apps</td><td>Uses virtual machines with a full OS</td></tr><tr><td>Shares host OS kernel (lightweight)</td><td>Each VM has its own OS (heavier)</td></tr><tr><td>Starts in seconds</td><td>Takes minutes to boot</td></tr><tr><td>Efficient resource usage</td><td>More resource-intensive</td></tr><tr><td>Ideal for microservices and CI/CD</td><td>Good for running multiple OS environments</td></tr></tbody></table>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/8b557715-1f08-43ae-ac1a-b814d80e7850/d829c88a-4fae-47a5-b9d7-3c298696d73c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&#x26;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&#x26;X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20250104%2Fus-west-2%2Fs3%2Faws4_request&#x26;X-Amz-Date=20250104T041405Z&#x26;X-Amz-Expires=3600&#x26;X-Amz-Signature=567e7bbccb7207f55009c97ef28cfc31e112216e5d12b8f901dc2e7e0f6651e7&#x26;X-Amz-SignedHeaders=host&#x26;x-id=GetObject\" alt=\"image.png\"></p>\n<p><img src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/8b557715-1f08-43ae-ac1a-b814d80e7850/cc6f4ac1-e9d5-4455-950b-9b3c5022b292/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&#x26;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&#x26;X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20250104%2Fus-west-2%2Fs3%2Faws4_request&#x26;X-Amz-Date=20250104T041405Z&#x26;X-Amz-Expires=3600&#x26;X-Amz-Signature=48e2841d1f58183c312f22b1825083a9e35d39b469b31eeb13a7476adb51175b&#x26;X-Amz-SignedHeaders=host&#x26;x-id=GetObject\" alt=\"image.png\"></p>\n<h3 id=\"quiz-for-you-2\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>Why are Docker containers considered more lightweight than virtual machines?</strong></summary>\n<ul>\n<li>\n<p>A) Containers share the host OS’s kernel.</p>\n</li>\n<li>\n<p>B) Containers include their own full operating systems.</p>\n</li>\n<li>\n<p>C) Containers can only run one service at a time.</p>\n</li>\n</ul>\n<p><em>(Answer: A)</em></p>\n</details>\n<hr>\n<h3 id=\"4-docker-and-its-form\"><strong>4. Docker and it’s form</strong></h3>\n<h3 id=\"docker-desktop\"><strong>Docker Desktop</strong></h3>\n<p><strong>Docker Desktop</strong> is an application that provides a local development environment for building, running, and testing Docker containers. It’s available for <strong>Windows</strong>, <strong>macOS</strong>, and <strong>Linux</strong>. Docker Desktop is perfect for developers who need a simple setup to get started with Docker.</p>\n<h3 id=\"docker-swarm\"><strong>Docker Swarm</strong></h3>\n<p><strong>Docker Swarm</strong> is Docker’s native orchestration tool. It allows you to manage and scale a cluster of Docker containers across multiple hosts. Swarm provides features like load balancing, service discovery, and scaling with minimal configuration.</p>\n<h3 id=\"quiz-for-you-3\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the purpose of Docker Swarm?</strong></summary>\n<ul>\n<li>\n<p>A) To manage a single container on one host.</p>\n</li>\n<li>\n<p>B) To orchestrate containers across multiple hosts.</p>\n</li>\n<li>\n<p>C) To create virtual machines for testing purposes.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"5-installing-docker\"><strong>5. Installing Docker</strong></h3>\n<p>Installing Docker is straightforward and varies slightly depending on your operating system. Here’s how to install Docker on Ubuntu:</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">sudo apt update\nsudo apt install docker.io\nsudo systemctl start docker\nsudo systemctl enable docker</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<p>For <strong>macOS</strong> and <strong>Windows</strong>, simply download <strong>Docker Desktop</strong> from the official Docker website and follow the installation instructions.</p>\n<p>Verify that Docker is installed:</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker --version</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"quiz-for-you-4\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>How do you verify that Docker has been installed correctly?</strong></summary>\n<ul>\n<li>\n<p>A) Run <code class=\"inline-code\">docker status</code></p>\n</li>\n<li>\n<p>B) Run <code class=\"inline-code\">docker —version</code></p>\n</li>\n<li>\n<p>C) Run <code class=\"inline-code\">docker start</code></p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"6-docker-images-and-containers\"><strong>6. Docker Images and Containers</strong></h3>\n<h3 id=\"what-is-a-docker-image\"><strong>What is a Docker Image?</strong></h3>\n<p>A <strong>Docker image</strong> is a read-only template that contains the instructions to create a container. Images include everything needed to run an application—such as code, libraries, and configurations.</p>\n<h3 id=\"what-is-a-docker-container\"><strong>What is a Docker Container?</strong></h3>\n<p>A <strong>container</strong> is a running instance of a Docker image. It provides an isolated environment to run your application without interfering with the rest of your system.</p>\n<h3 id=\"quiz-for-you-5\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the relationship between Docker images and containers?</strong></summary>\n<ul>\n<li>\n<p>A) An image is a running instance of a container.</p>\n</li>\n<li>\n<p>B) A container is a running instance of an image.</p>\n</li>\n<li>\n<p>C) A container contains Docker images.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"how-to-pull-docker-images\"><strong>How to Pull Docker Images</strong></h3>\n<p>Docker images can be pulled from Docker Hub, a public repository for Docker images.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker pull <image-name></image-name></code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"example\">Example:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker pull nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<p>This command pulls the latest version of the <strong>nginx</strong> web server image from Docker Hub.</p>\n<h3 id=\"real-world-scenario\">Real-World Scenario:</h3>\n<p>You’re setting up a web server for testing purposes and need to download the NGINX image to create a container.</p>\n<h3 id=\"quiz-for-you-6\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>Where do you typically pull Docker images from?</strong></summary>\n<ul>\n<li>\n<p>A) Docker Swarm</p>\n</li>\n<li>\n<p>B) Docker Hub</p>\n</li>\n<li>\n<p>C) Docker Engine</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"working-with-docker-containers\"><strong>Working with Docker Containers</strong></h3>\n<p>To create and run a container from an image:</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d -p 80:80 nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"real-world-scenario-1\">Real-World Scenario:</h3>\n<p>This command runs an NGINX container in <strong>detached mode</strong> (<code class=\"inline-code\">-d</code>) and maps port 80 of the container to port 80 of the host (<code class=\"inline-code\">-p</code>). Now, you can access the NGINX server at <code class=\"inline-code\"><a href=\"http://localhost\">http://localhost</a></code>.</p>\n<h3 id=\"quiz-for-you-7\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What does the</strong> <strong><code class=\"inline-code\">docker run -d</code></strong> <strong>flag do when running a container?</strong></summary>\n<ul>\n<li>\n<p>A) Deletes the container after running.</p>\n</li>\n<li>\n<p>B) Runs the container in detached mode.</p>\n</li>\n<li>\n<p>C) Duplicates the container.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"7-dockerfiles-building-your-own-docker-image\"><strong>7. Dockerfiles: Building Your Own Docker Image</strong></h3>\n<p>A <strong>Dockerfile</strong> is a text file that contains instructions on how to build a Docker image. It specifies the base image, environment variables, dependencies, and application code that will be included in the container.</p>\n<h3 id=\"writing-a-dockerfile\"><strong>Writing a Dockerfile</strong></h3>\n<p>Here’s an example of a simple <strong>Dockerfile</strong> for a Node.js application:</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-text\">\\# Use the official Node.js image as the base image\nFROM node:14\n<p># Set the working directory inside the container\nWORKDIR /app</p>\n<p># Copy package.json and install dependencies\nCOPY package.json .\nRUN npm install</p>\n<p># Copy the rest of the application code\nCOPY . .</p>\n<p># Expose the app’s port\nEXPOSE 3000</p>\n</code><p><code class=\"language-text\"># Start the application\nCMD [“npm”, “start”]</code><button class=\"copy-button\">Copy</button></p></pre><p></p>\n</div>\n<h3 id=\"steps-in-a-dockerfile\"><strong>Steps in a Dockerfile</strong>:</h3>\n<ol>\n<li><strong>FROM</strong>: Specifies the base image (in this case, <code class=\"inline-code\">node:14</code>).</li>\n<li><strong>WORKDIR</strong>: Sets the working directory inside the container.</li>\n<li><strong>COPY</strong>: Copies files from your local machine to the container.</li>\n<li><strong>RUN</strong>: Runs a command (e.g., <code class=\"inline-code\">npm install</code>) inside the container.</li>\n<li><strong>EXPOSE</strong>: Opens a port (3000 in this case) to allow communication with the container.</li>\n<li><strong>CMD</strong>: Specifies the command that will run when the container starts.</li>\n</ol>\n<h3 id=\"building-a-docker-image\">Building a Docker Image:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker build -t myapp:latest .</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<p>This command builds the Docker image from the Dockerfile in the current directory and tags it as <code class=\"inline-code\">myapp:latest</code>.</p>\n<h3 id=\"quiz-for-you-8\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the purpose of the</strong> <strong><code class=\"inline-code\">FROM</code></strong> <strong>instruction in a Dockerfile?</strong></summary>\n<ul>\n<li>\n<p>A) To create a new directory inside the container.</p>\n</li>\n<li>\n<p>B) To specify the base image from which to build the container.</p>\n</li>\n<li>\n<p>C) To run commands inside the container.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"8-docker-networking\"><strong>8. Docker Networking</strong></h3>\n<p><strong>Docker Networking</strong> enables communication between containers and the outside world or between containers in a cluster. Docker automatically sets up a <strong>bridge network</strong> for containers by default.</p>\n<h3 id=\"creating-a-custom-network\">Creating a Custom Network:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker network create my-network</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<p>You can attach containers to this network:</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d --name web --network my-network nginx\ndocker run -d --name db --network my-network postgres</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"real-world-scenario-2\">Real-World Scenario:</h3>\n<p>You’re building a multi-tier application where a <strong>web container</strong> (NGINX) and a <strong>database container</strong> (Postgres) need to communicate. By attaching them to the same network (<code class=\"inline-code\">my-network</code>), they can communicate using their container names as hostnames.</p>\n<h3 id=\"quiz-for-you-9\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>Why would you create a custom Docker network?</strong></summary>\n<ul>\n<li>\n<p>A) To increase container resource usage.</p>\n</li>\n<li>\n<p>B) To enable containers to communicate with each other.</p>\n</li>\n<li>\n<p>C) To isolate containers from one another.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"9-docker-volumes-persistent-storage\"><strong>9. Docker Volumes: Persistent Storage</strong></h3>\n<p>Docker containers are typically <strong>stateless</strong>, meaning any data generated inside the container is lost when the container stops. <strong>Volumes</strong> provide a way to persist data by storing it outside the container.</p>\n<h3 id=\"creating-a-volume\">Creating a Volume:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker volume create my-volume</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"attaching-a-volume-to-a-container\">Attaching a Volume to a Container:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker run -d -v my-volume:/app/data nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"real-world-scenario-3\">Real-World Scenario:</h3>\n<p>You need to persist data (such as logs or database files) generated by an application inside the container. Using volumes, you ensure that the data remains available even if the container is stopped or removed.</p>\n<h3 id=\"quiz-for-you-10\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the purpose of Docker volumes?</strong></summary>\n<ul>\n<li>\n<p>A) To increase the CPU usage of containers.</p>\n</li>\n<li>\n<p>B) To persist data beyond the lifecycle of a container.</p>\n</li>\n<li>\n<p>C) To automatically replicate data between containers.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"10-docker-compose\"><strong>10. Docker Compose</strong></h3>\n<p><strong>Docker Compose</strong> simplifies multi-container deployments. You define your services in a <code class=\"inline-code\">docker-compose.yml</code> file, and Docker Compose brings them up with a single command.</p>\n<h3 id=\"example-docker-composeyml\">Example <code class=\"inline-code\">docker-compose.yml</code>:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-yaml\">version: '3'\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"80:80\"\n  db:\n    image: postgres\n    environment:\n      POSTGRES_PASSWORD: example\n</code><p><code class=\"language-yaml\">volumes:\ndb-data:</code><button class=\"copy-button\">Copy</button></p></pre><p></p>\n</div>\n<h3 id=\"starting-the-application\">Starting the Application:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker-compose up -d</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"real-world-scenario-4\">Real-World Scenario:</h3>\n<p>You’re deploying an NGINX web server and a Postgres database as part of a development environment. Instead of running multiple <code class=\"inline-code\">docker run</code> commands, you define both services in a <code class=\"inline-code\">docker-compose.yml</code> file and start them with one command.</p>\n<h3 id=\"quiz-for-you-11\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is the advantage of using Docker Compose?</strong></summary>\n<ul>\n<li>\n<p>A) It only runs one container at a time.</p>\n</li>\n<li>\n<p>B) It allows for multi-container deployments with a single command.</p>\n</li>\n<li>\n<p>C) It increases the memory usage of containers.</p>\n</li>\n</ul>\n<p><em>(Answer: B)</em></p>\n</details>\n<hr>\n<h3 id=\"11-docker-swarm-orchestration-simplified\"><strong>11. Docker Swarm: Orchestration Simplified</strong></h3>\n<p><strong>Docker Swarm</strong> is Docker’s native solution for orchestrating containers across multiple hosts. It simplifies tasks such as load balancing, service discovery, and scaling.</p>\n<h3 id=\"initializing-a-docker-swarm\">Initializing a Docker Swarm:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker swarm init</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"adding-worker-nodes\">Adding Worker Nodes:</h3>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker swarm join --token <worker-token> <manager-ip></manager-ip></worker-token></code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"real-world-scenario-5\">Real-World Scenario:</h3>\n<p>You want to deploy a scalable application across multiple hosts. Using Docker Swarm, you can create a cluster of machines (nodes) that run containers. Docker Swarm will handle load balancing and service scaling for you.</p>\n<h3 id=\"quiz-for-you-12\"><strong>Quiz for You!</strong></h3>\n<details>\n<summary><strong>What is Docker Swarm used for?</strong></summary>\n<ul>\n<li>\n<p>A) Managing and scaling containers across multiple hosts.</p>\n</li>\n<li>\n<p>B) Running containers on a single machine only.</p>\n</li>\n<li>\n<p>C) Replacing Docker Compose.</p>\n</li>\n</ul>\n<p><em>(Answer: A)</em></p>\n</details>\n<hr>\n<h3 id=\"12-alternatives-to-docker\"><strong>12. Alternatives to Docker</strong></h3>\n<p>While Docker is the most widely adopted container platform, there are alternatives worth noting:</p>\n<ul>\n<li><strong>Podman</strong>: A daemonless container engine that’s compatible with Docker commands.</li>\n<li><strong>Kubernetes</strong>: A powerful orchestration tool for managing containers at scale, often used with Docker for large, complex deployments.</li>\n<li><strong>LXC/LXD</strong>: Linux container technologies that provide full system containers for running multiple Linux distributions.</li>\n</ul>\n<hr>\n<h3 id=\"13-real-world-use-cases-for-docker-in-devops\"><strong>13. Real-World Use Cases for Docker in DevOps</strong></h3>\n<ul>\n<li><strong>CI/CD Pipelines</strong>: Docker integrates seamlessly with continuous integration and delivery tools like Jenkins, GitLab CI, and CircleCI, ensuring that each build runs in a consistent environment.</li>\n<li><strong>Microservices</strong>: Docker makes it easy to deploy microservices, where each service runs in its own container, making scaling and updating services simple.</li>\n<li><strong>Testing and Development</strong>: Developers can use Docker to quickly spin up isolated environments for testing new features, without affecting their local machine or other services.</li>\n</ul>\n<hr>\n<h3 id=\"14-complete-list-of-docker-commands-with-examples-and-flags\"><strong>14. Complete List of Docker Commands (With Examples and Flags)</strong></h3>\n<p>Below is a comprehensive list of Docker commands, along with real-world examples and explanations of a running container.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker exec -it myweb /bin/bash</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<ul>\n<li><strong>Flags</strong>:\n<ul>\n<li><strong><code class=\"inline-code\">it</code></strong>: Interactive terminal (connect to the container’s shell).</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-docker-build\"><strong>9.</strong> <strong><code class=\"inline-code\">docker build</code></strong></h3>\n<p><strong>Definition</strong>: Builds an image from a Dockerfile.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker build -t myapp:latest .</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<ul>\n<li><strong>Flags</strong>:\n<ul>\n<li><strong><code class=\"inline-code\">t</code></strong>: Tags the image with a name.</li>\n<li><strong><code class=\"inline-code\">-no-cache</code></strong>: Builds the image without using cache.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"10-docker-logs\"><strong>10.</strong> <strong><code class=\"inline-code\">docker logs</code></strong></h3>\n<p><strong>Definition</strong>: Fetches logs from a container.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker logs -f myweb</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<ul>\n<li><strong>Flags</strong>:\n<ul>\n<li><strong><code class=\"inline-code\">f</code></strong>: Follow logs (like <code class=\"inline-code\">tail -f</code>).</li>\n<li><strong><code class=\"inline-code\">-since</code></strong>: Show logs since a specific time.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"11-docker-inspect\"><strong>11.</strong> <strong><code class=\"inline-code\">docker inspect</code></strong></h3>\n<p><strong>Definition</strong>: Shows detailed information about a Docker object.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker inspect myweb</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"12-docker-volume\"><strong>12.</strong> <strong><code class=\"inline-code\">docker volume</code></strong></h3>\n<p><strong>Definition</strong>: Manages Docker volumes.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker volume create myvolume\ndocker run -d -v myvolume:/app/data nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"13-docker-network\"><strong>13.</strong> <strong><code class=\"inline-code\">docker network</code></strong></h3>\n<p><strong>Definition</strong>: Manages Docker networks.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker network create my-network\ndocker run -d --network my-network --name web nginx</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"14-docker-compose\"><strong>14.</strong> <strong><code class=\"inline-code\">docker-compose</code></strong></h3>\n<p><strong>Definition</strong>: Defines and runs multi-container applications.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker-compose up -d</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<h3 id=\"15-docker-stats\"><strong>15.</strong> <strong><code class=\"inline-code\">docker stats</code></strong></h3>\n<p><strong>Definition</strong>: Displays real-time resource usage statistics for running containers.</p>\n<div class=\"code-block-wrapper\">\n  <pre><code class=\"language-shell\">docker stats</code><button class=\"copy-button\">Copy</button></pre>\n</div>\n<ul>\n<li><strong>Flags</strong>:\n<ul>\n<li><strong><code class=\"inline-code\">-no-stream</code></strong>: Shows only the first result and does not update continuously.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"conclusion\"><strong>Conclusion</strong></h3>\n<p>Docker is an incredibly powerful tool for DevOps, allowing you to manage application development, testing, and deployment in a consistent and efficient way. From running simple containers to orchestrating multi-container applications using Docker Swarm, Docker provides all the tools you need for modern software delivery.</p>\n<p>By mastering the commands and techniques covered in this guide, you’ll be well on your way to becoming proficient in Docker and leveraging it to streamline your DevOps workflows.</p>",{headings:23,localImagePaths:188,remoteImagePaths:189,frontmatter:190,imagePaths:202},[24,28,31,34,37,40,42,45,47,50,53,56,58,61,63,66,69,72,74,77,80,83,85,88,90,92,95,98,101,104,106,109,112,114,116,119,122,125,127,129,132,135,138,140,142,145,148,151,153,155,158,161,164,167,170,173,176,179,182,185],{depth:25,slug:26,text:27},3,"table-of-contents","Table of Contents",{depth:25,slug:29,text:30},"1-what-is-docker","1. What is Docker?",{depth:25,slug:32,text:33},"why-containers","Why Containers?",{depth:25,slug:35,text:36},"quiz-for-you","Quiz for You!",{depth:25,slug:38,text:39},"2-why-docker-for-devops","2. Why Docker for DevOps?",{depth:25,slug:41,text:36},"quiz-for-you-1",{depth:25,slug:43,text:44},"3-docker-vs-virtual-machines","3. Docker vs. Virtual Machines",{depth:25,slug:46,text:36},"quiz-for-you-2",{depth:25,slug:48,text:49},"4-docker-and-its-form","4. Docker and it’s form",{depth:25,slug:51,text:52},"docker-desktop","Docker Desktop",{depth:25,slug:54,text:55},"docker-swarm","Docker Swarm",{depth:25,slug:57,text:36},"quiz-for-you-3",{depth:25,slug:59,text:60},"5-installing-docker","5. Installing Docker",{depth:25,slug:62,text:36},"quiz-for-you-4",{depth:25,slug:64,text:65},"6-docker-images-and-containers","6. Docker Images and Containers",{depth:25,slug:67,text:68},"what-is-a-docker-image","What is a Docker Image?",{depth:25,slug:70,text:71},"what-is-a-docker-container","What is a Docker Container?",{depth:25,slug:73,text:36},"quiz-for-you-5",{depth:25,slug:75,text:76},"how-to-pull-docker-images","How to Pull Docker Images",{depth:25,slug:78,text:79},"example","Example:",{depth:25,slug:81,text:82},"real-world-scenario","Real-World Scenario:",{depth:25,slug:84,text:36},"quiz-for-you-6",{depth:25,slug:86,text:87},"working-with-docker-containers","Working with Docker Containers",{depth:25,slug:89,text:82},"real-world-scenario-1",{depth:25,slug:91,text:36},"quiz-for-you-7",{depth:25,slug:93,text:94},"7-dockerfiles-building-your-own-docker-image","7. Dockerfiles: Building Your Own Docker Image",{depth:25,slug:96,text:97},"writing-a-dockerfile","Writing a Dockerfile",{depth:25,slug:99,text:100},"steps-in-a-dockerfile","Steps in a Dockerfile:",{depth:25,slug:102,text:103},"building-a-docker-image","Building a Docker Image:",{depth:25,slug:105,text:36},"quiz-for-you-8",{depth:25,slug:107,text:108},"8-docker-networking","8. Docker Networking",{depth:25,slug:110,text:111},"creating-a-custom-network","Creating a Custom Network:",{depth:25,slug:113,text:82},"real-world-scenario-2",{depth:25,slug:115,text:36},"quiz-for-you-9",{depth:25,slug:117,text:118},"9-docker-volumes-persistent-storage","9. Docker Volumes: Persistent Storage",{depth:25,slug:120,text:121},"creating-a-volume","Creating a Volume:",{depth:25,slug:123,text:124},"attaching-a-volume-to-a-container","Attaching a Volume to a Container:",{depth:25,slug:126,text:82},"real-world-scenario-3",{depth:25,slug:128,text:36},"quiz-for-you-10",{depth:25,slug:130,text:131},"10-docker-compose","10. Docker Compose",{depth:25,slug:133,text:134},"example-docker-composeyml","Example docker-compose.yml:",{depth:25,slug:136,text:137},"starting-the-application","Starting the Application:",{depth:25,slug:139,text:82},"real-world-scenario-4",{depth:25,slug:141,text:36},"quiz-for-you-11",{depth:25,slug:143,text:144},"11-docker-swarm-orchestration-simplified","11. Docker Swarm: Orchestration Simplified",{depth:25,slug:146,text:147},"initializing-a-docker-swarm","Initializing a Docker Swarm:",{depth:25,slug:149,text:150},"adding-worker-nodes","Adding Worker Nodes:",{depth:25,slug:152,text:82},"real-world-scenario-5",{depth:25,slug:154,text:36},"quiz-for-you-12",{depth:25,slug:156,text:157},"12-alternatives-to-docker","12. Alternatives to Docker",{depth:25,slug:159,text:160},"13-real-world-use-cases-for-docker-in-devops","13. Real-World Use Cases for Docker in DevOps",{depth:25,slug:162,text:163},"14-complete-list-of-docker-commands-with-examples-and-flags","14. Complete List of Docker Commands (With Examples and Flags)",{depth:25,slug:165,text:166},"9-docker-build","9. docker build",{depth:25,slug:168,text:169},"10-docker-logs","10. docker logs",{depth:25,slug:171,text:172},"11-docker-inspect","11. docker inspect",{depth:25,slug:174,text:175},"12-docker-volume","12. docker volume",{depth:25,slug:177,text:178},"13-docker-network","13. docker network",{depth:25,slug:180,text:181},"14-docker-compose","14. docker-compose",{depth:25,slug:183,text:184},"15-docker-stats","15. docker stats",{depth:25,slug:186,text:187},"conclusion","Conclusion",[],[],{title:14,description:15,date:191,dateFormatted:16,tags:192,coverImage:198,lastUpdated:199,status:200,author:201},["Date","2025-01-02T00:00:00.000Z"],[193,194,195,196,197],"Docker","DevOps","Tutorials","Kubernetes","Cloud Computing","https://prod-files-secure.s3.us-west-2.amazonaws.com/8b557715-1f08-43ae-ac1a-b814d80e7850/12726ca8-0ba5-4667-a1a1-5351098ff788/docker-logo-blue.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45FSPPWI6X%2F20250104%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250104T041356Z&X-Amz-Expires=3600&X-Amz-Signature=a40cbe4fa22768fb60f4d4c5e9d3a10d2eceee0754ae9ce5d3f564f010d0387f&X-Amz-SignedHeaders=host&x-id=GetObject",["Date","2025-01-03T22:49:00.000Z"],"Published","iemafzalhassan",[],"test.md","gallary-app-deploy",{id:204,data:206,body:210,filePath:211,digest:212,rendered:213,legacyId:263},{title:207,description:208,dateFormatted:209},"🚀 Deploying a Gallery App with Docker, Jenkins, and EC2","A complete DevOps journey where we build and deploy a React + Firebase Gallery App using Docker, Jenkins, and AWS EC2. Even if you're new to CI/CD or cloud deployment, this guide walks you through every step clearly.","Sepember 10, 2025","<img src=\"/assets/images/pro--/EMP.png\" alt=\"logo\" width=\"800\"/>\n\n\nIn this article, we’ll walk through the journey of building, containerizing, scanning, and deploying a React + Firebase Gallery App using Docker, Jenkins CI/CD, and AWS EC2.  \nThis guide is written so that even if you are new to DevOps or cloud deployment, you can follow step by step and understand why each part matters.\n\n**Project Repo Link..**\n- [Repo Link](https://github.com/muhammadiishaq/Gallery-Website-Deploy-)\n\n---\n\n## 📸 About the Project\n\nThis is a simple Gallery App built with:\n\n- React (frontend)  \n- Firebase (authentication + storage)  \n- TailwindCSS (styling)  \n\nThe app allows you to:\n\n✅ Upload and download images  \n✅ Log in/out securely  \n✅ Manage your personal gallery\n\nWhile the app itself is simple, the real power comes in how we deploy it. We’ll use modern DevOps practices to ensure the app can be shipped quickly, securely, and reliably.\n\n---\n\n## ⚡ Step 1: Running Locally\n\nBefore thinking about Docker or Jenkins, you should always confirm the app runs locally.\n\n```\n1. Clone the repo:\ngit clone https://github.com/your-username/gallery-app.git\ncd gallery-app\n\n2. Install dependencies:\nnpm install\n\n3. Start development server:\nnpm run dev\n```\nBy default, the app is available at: 👉 http://localhost:5173\n```\n4. For a production build:\nnpm run bu\n```\nThis creates a dist/ folder containing optimized static assets.\n\n## 🐳 Step 2: Containerizing with Docker\n\nInstead of manually building and serving files, let’s use Docker. Docker helps us ship the app anywhere without worrying about environment differences.\n\n### Dockerfile\n```\n# Stage 1: Build the app\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# Stage 2: Serve with Nginx\nFROM nginx:alpine\nRUN rm -rf /usr/share/nginx/html/*\nCOPY --from=builder /app/dist /usr/share/nginx/html\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n## 👉 Why multi-stage?\n\n1. First stage (node:18-alpine) builds the React app.\n\n2. Second stage (nginx:alpine) serves only the optimized static files.\n\n3. This keeps the final image lightweight and production-ready.\n```\ndocker build -t gallery-app:latest .\ndocker run -d -p 80:80 --name gallery-app-cont gallery-app:latest\n```\nNow, open http://localhost\nand your app is live 🎉...\n\n## ⚙️ Step 3: Automating with Jenkins\n\nManual builds are fine for testing, but in real-world projects we use CI/CD pipelines to automate everything.\n\nWe’ll use Jenkins on EC2 to:\n\nClone the code\n\nBuild Docker image\n\nScan image with Trivy (security scan)\n\nPush to DockerHub\n\nDeploy container on EC2\n\n👉 A Jenkinsfile is already included in the repository. Make sure to review it for the full pipeline definition.\n\n## 🔒 Step 4: Security Scanning with Trivy\n\nSecurity is critical. That’s why before pushing our image to DockerHub, First check that trivy install and update..\n```\ntrivy image gallery-app:latest\n```\nThis checks for vulnerabilities in our base images (node:18-alpine, nginx:alpine) and dependencies.\n\n## 📤 Step 5: Pushing to DockerHub\n\nOnce the image is scanned, the pipeline pushes it to DockerHub.\n\nIf something fails in the pipeline, you can also push manually:\n```\ndocker tag gallery-app:latest your-dockerhub-username/gallery-app:latest\ndocker push your-dockerhub-username/gallery-app:latest\n```\n\n🌍 Step 6: Deploying on EC2\n\nFinally, we deploy on our EC2 server.\n\n1. If the pipeline succeeds, this is automatic.\n\n2. If not, you can also do it manually:\n```\ndocker pull your-dockerhub-username/gallery-app:latest\ndocker run -d -p 80:80 --name gallery-app-cont your-dockerhub-username/gallery-app:latest\n```\n\nNow, visit your EC2 public IP in the browser and your Gallery App is live..... 🚀\n\n## ✅ Overall Flow\n\n1. Run locally (npm run dev)\n2. Build and serve with Docker\n3. Jenkins pipeline automates build → scan → push → deploy\n4. App runs on EC2, accessible on port 80\n\n## 🤝 Contributing\n\nIf you like this project:\n\n⭐ Star the repo\n🍴 Fork it and experiment\n🛠️ Contribute via pull requests\n\n## Thanks for supporting this project 💙\n🔗 Follow Me for More Content\n\n- [GitHub](https://github.com/muhammadiishaq)  \n- [LinkedIn](https://www.linkedin.com/in/muhammadishaq-khan/)\n- [Mediam](https://medium.com/@muhammadishaqpak801)  \n\n🔥 With this setup, you have not only built a cool Gallery App, but also learned how to apply DevOps practices (CI/CD, Docker, Scanning, Deployment) to make your app production-ready.","src/content/post/Gallary app Deploy.md","81044cd14720deaf",{html:214,metadata:215},"<img src=\"/assets/images/pro--/EMP.png\" alt=\"logo\" width=\"800\">\n<p>In this article, we’ll walk through the journey of building, containerizing, scanning, and deploying a React + Firebase Gallery App using Docker, Jenkins CI/CD, and AWS EC2.<br>\nThis guide is written so that even if you are new to DevOps or cloud deployment, you can follow step by step and understand why each part matters.</p>\n<p><strong>Project Repo Link..</strong></p>\n<ul>\n<li><a href=\"https://github.com/muhammadiishaq/Gallery-Website-Deploy-\">Repo Link</a></li>\n</ul>\n<hr>\n<h2 id=\"-about-the-project\">📸 About the Project</h2>\n<p>This is a simple Gallery App built with:</p>\n<ul>\n<li>React (frontend)</li>\n<li>Firebase (authentication + storage)</li>\n<li>TailwindCSS (styling)</li>\n</ul>\n<p>The app allows you to:</p>\n<p>✅ Upload and download images<br>\n✅ Log in/out securely<br>\n✅ Manage your personal gallery</p>\n<p>While the app itself is simple, the real power comes in how we deploy it. We’ll use modern DevOps practices to ensure the app can be shipped quickly, securely, and reliably.</p>\n<hr>\n<h2 id=\"-step-1-running-locally\">⚡ Step 1: Running Locally</h2>\n<p>Before thinking about Docker or Jenkins, you should always confirm the app runs locally.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>1. Clone the repo:</span></span>\n<span class=\"line\"><span>git clone https://github.com/your-username/gallery-app.git</span></span>\n<span class=\"line\"><span>cd gallery-app</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>2. Install dependencies:</span></span>\n<span class=\"line\"><span>npm install</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>3. Start development server:</span></span>\n<span class=\"line\"><span>npm run dev</span></span></code></pre>\n<p>By default, the app is available at: 👉 <a href=\"http://localhost:5173\">http://localhost:5173</a></p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>4. For a production build:</span></span>\n<span class=\"line\"><span>npm run bu</span></span></code></pre>\n<p>This creates a dist/ folder containing optimized static assets.</p>\n<h2 id=\"-step-2-containerizing-with-docker\">🐳 Step 2: Containerizing with Docker</h2>\n<p>Instead of manually building and serving files, let’s use Docker. Docker helps us ship the app anywhere without worrying about environment differences.</p>\n<h3 id=\"dockerfile\">Dockerfile</h3>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Stage 1: Build the app</span></span>\n<span class=\"line\"><span>FROM node:18-alpine AS builder</span></span>\n<span class=\"line\"><span>WORKDIR /app</span></span>\n<span class=\"line\"><span>COPY package*.json ./</span></span>\n<span class=\"line\"><span>RUN npm install</span></span>\n<span class=\"line\"><span>COPY . .</span></span>\n<span class=\"line\"><span>RUN npm run build</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span># Stage 2: Serve with Nginx</span></span>\n<span class=\"line\"><span>FROM nginx:alpine</span></span>\n<span class=\"line\"><span>RUN rm -rf /usr/share/nginx/html/*</span></span>\n<span class=\"line\"><span>COPY --from=builder /app/dist /usr/share/nginx/html</span></span>\n<span class=\"line\"><span>EXPOSE 80</span></span>\n<span class=\"line\"><span>CMD [\"nginx\", \"-g\", \"daemon off;\"]</span></span></code></pre>\n<h2 id=\"-why-multi-stage\">👉 Why multi-stage?</h2>\n<ol>\n<li>\n<p>First stage (node:18-alpine) builds the React app.</p>\n</li>\n<li>\n<p>Second stage (nginx:alpine) serves only the optimized static files.</p>\n</li>\n<li>\n<p>This keeps the final image lightweight and production-ready.</p>\n</li>\n</ol>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>docker build -t gallery-app:latest .</span></span>\n<span class=\"line\"><span>docker run -d -p 80:80 --name gallery-app-cont gallery-app:latest</span></span></code></pre>\n<p>Now, open <a href=\"http://localhost\">http://localhost</a>\nand your app is live 🎉…</p>\n<h2 id=\"️-step-3-automating-with-jenkins\">⚙️ Step 3: Automating with Jenkins</h2>\n<p>Manual builds are fine for testing, but in real-world projects we use CI/CD pipelines to automate everything.</p>\n<p>We’ll use Jenkins on EC2 to:</p>\n<p>Clone the code</p>\n<p>Build Docker image</p>\n<p>Scan image with Trivy (security scan)</p>\n<p>Push to DockerHub</p>\n<p>Deploy container on EC2</p>\n<p>👉 A Jenkinsfile is already included in the repository. Make sure to review it for the full pipeline definition.</p>\n<h2 id=\"-step-4-security-scanning-with-trivy\">🔒 Step 4: Security Scanning with Trivy</h2>\n<p>Security is critical. That’s why before pushing our image to DockerHub, First check that trivy install and update..</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>trivy image gallery-app:latest</span></span></code></pre>\n<p>This checks for vulnerabilities in our base images (node:18-alpine, nginx:alpine) and dependencies.</p>\n<h2 id=\"-step-5-pushing-to-dockerhub\">📤 Step 5: Pushing to DockerHub</h2>\n<p>Once the image is scanned, the pipeline pushes it to DockerHub.</p>\n<p>If something fails in the pipeline, you can also push manually:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>docker tag gallery-app:latest your-dockerhub-username/gallery-app:latest</span></span>\n<span class=\"line\"><span>docker push your-dockerhub-username/gallery-app:latest</span></span></code></pre>\n<p>🌍 Step 6: Deploying on EC2</p>\n<p>Finally, we deploy on our EC2 server.</p>\n<ol>\n<li>\n<p>If the pipeline succeeds, this is automatic.</p>\n</li>\n<li>\n<p>If not, you can also do it manually:</p>\n</li>\n</ol>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>docker pull your-dockerhub-username/gallery-app:latest</span></span>\n<span class=\"line\"><span>docker run -d -p 80:80 --name gallery-app-cont your-dockerhub-username/gallery-app:latest</span></span></code></pre>\n<p>Now, visit your EC2 public IP in the browser and your Gallery App is live… 🚀</p>\n<h2 id=\"-overall-flow\">✅ Overall Flow</h2>\n<ol>\n<li>Run locally (npm run dev)</li>\n<li>Build and serve with Docker</li>\n<li>Jenkins pipeline automates build → scan → push → deploy</li>\n<li>App runs on EC2, accessible on port 80</li>\n</ol>\n<h2 id=\"-contributing\">🤝 Contributing</h2>\n<p>If you like this project:</p>\n<p>⭐ Star the repo\n🍴 Fork it and experiment\n🛠️ Contribute via pull requests</p>\n<h2 id=\"thanks-for-supporting-this-project\">Thanks for supporting this project 💙</h2>\n<p>🔗 Follow Me for More Content</p>\n<ul>\n<li><a href=\"https://github.com/muhammadiishaq\">GitHub</a></li>\n<li><a href=\"https://www.linkedin.com/in/muhammadishaq-khan/\">LinkedIn</a></li>\n<li><a href=\"https://medium.com/@muhammadishaqpak801\">Mediam</a></li>\n</ul>\n<p>🔥 With this setup, you have not only built a cool Gallery App, but also learned how to apply DevOps practices (CI/CD, Docker, Scanning, Deployment) to make your app production-ready.</p>",{headings:216,localImagePaths:251,remoteImagePaths:252,frontmatter:253,imagePaths:262},[217,221,224,227,230,233,236,239,242,245,248],{depth:218,slug:219,text:220},2,"-about-the-project","📸 About the Project",{depth:218,slug:222,text:223},"-step-1-running-locally","⚡ Step 1: Running Locally",{depth:218,slug:225,text:226},"-step-2-containerizing-with-docker","🐳 Step 2: Containerizing with Docker",{depth:25,slug:228,text:229},"dockerfile","Dockerfile",{depth:218,slug:231,text:232},"-why-multi-stage","👉 Why multi-stage?",{depth:218,slug:234,text:235},"️-step-3-automating-with-jenkins","⚙️ Step 3: Automating with Jenkins",{depth:218,slug:237,text:238},"-step-4-security-scanning-with-trivy","🔒 Step 4: Security Scanning with Trivy",{depth:218,slug:240,text:241},"-step-5-pushing-to-dockerhub","📤 Step 5: Pushing to DockerHub",{depth:218,slug:243,text:244},"-overall-flow","✅ Overall Flow",{depth:218,slug:246,text:247},"-contributing","🤝 Contributing",{depth:218,slug:249,text:250},"thanks-for-supporting-this-project","Thanks for supporting this project 💙",[],[],{title:207,description:208,date:254,dateFormatted:209,tags:255,coverImage:259,lastUpdated:260,status:200,author:261},["Date","2025-09-24T00:00:00.000Z"],[194,197,256,193,257,195,258],"AWS","CI/CD","infrastructure","https://images.unsplash.com/photo-1629904853893-c2c8981a1dc5?ixlib=rb-4.0.3&q=85&fm=jpg&crop=entropy&cs=srgb",["Date","2025-09-24T01:06:00.000Z"],"Muhammad Ishaq",[],"Gallary app Deploy.md","docker-images-type",{id:264,data:266,body:270,filePath:271,digest:272,rendered:273,legacyId:323},{title:267,description:268,dateFormatted:269},"Types of Docker Base Images Explained (with Sizes & Use Cases)..🐳","Choosing the right Docker base image affects size, speed, and security — from full-featured Normal images to ultra-minimal Distroles","Sepember 09, 2025","<img src=\"/assets/images/posts/Docker images-type.webp\" alt=\"logo\" width=\"800\"/>\n\n\n## When building Docker containers, the image you choose makes a huge difference not just in size, but also in security, speed, and how easy it is to manage your app.\n\n### In this article, we’ll break down the 4 most common Docker image types:\n1: Normal\n2: Slim\n3: Alpine\n4: Distroless\n\nYou will also get real commands, size comparisons, and tips on when to use each one.\n\n## What Is a Docker Image? (Lets Recap)…..🚢\nThink of a Docker image like a mini-computer. It has an operating system, tools, and your app inside. But just like real computers, some images are heavy and full-featured, while others are small and secure.\n\n## 🏋️ 1. Normal Images — The Full Package Means Full OS..\n- Size: 800 MB to 2 GB+\n- Shell Access: Yes\n- Good for: Development, debugging, and full control\n\nNormal images come with everything — a full OS (like Ubuntu or Debian), package managers, compilers, and debugging tools.\n\n## ✅ Use when:\n- You’re actively building or debugging\n- You need access to the terminal or tools like curl, vim, gcc, etc.\n```\n# Pull the slim image\ndocker pull python:3.9-slim\n```\n\n```\n# see size of images\ndocker images\n# Run container and open shell\ndocker run -it python:3.9-slim bash\n# Inside container see files and compare with other images\ncd /bin\n```\n## 🧪 2. Slim Images — Lighter but Still Flexible..\n- Size: Around 400–900 MB\n- Shell Access: Yes\n- Good for: Smaller builds, test environments\nSlim images are lighter versions of normal ones. They remove unnecessary tools (like build dependencies), but still give you shell access and some debugging features.\n\n## ✅ Use when:\nYou want smaller images but still need a shell\nYou’re testing or doing light development\n```\n# Pull the slim image\ndocker pull python:3.9-slim\n```\n```\n# see size of images\ndocker images\n```\n```\n# Run container and open shell\ndocker run -it python:3.9-slim bash\n# Inside container see files and compare with other images\ncd /bin\nls\n```\n\n## 🏃 3. Alpine Images — Super Lightweight\n- Size: ~5 MB\n- Shell Access: Yes (BusyBox)\n- Good for: Lightweight apps, microservices\nAlpine is a tiny Linux distribution designed for containers. It has a shell and package manager (apk), but not much else.\n\n## ✅ Use when:\nYou care a lot about size and speed\nYour app doesn’t need a lot of OS tools\n```\n# Pull the slim image\ndocker pull alpine\n```\n```\n# see size of images\ndocker images alpine\n```\n```\n# Run container and open shell\ndocker run -it alpine sh\n# Inside container see files and compare with other images\ncd /bin\nls\n```\n\n## 🛡️ 4. Distroless Images — Ultra Secure & Minimal\n- Size: ~2–20 MB\n- Shell Access: ❌ No\n- Good for: Production only (no debugging)\nDistroless images are the most secure and smallest. They do not include a shell, package manager, or OS tools — only your app and runtime.\n\n## ✅ Use when:\nYou’re deploying to production\nYou want maximum security and minimal size\n```\n# Pull the slim image\ndocker pull gcr.io/distroless/base\n```\n```\n# see size of images\ndocker images gcr.io/distroless/base\n```\n```\n# Run container and no shell give you error \ndocker run -it gcr.io/distroless/base  # error\n```\n\n## 📝 Summary\nThis guide explains the four main types of Docker base images — Normal, Slim, Alpine, and Distroless — and how they impact image size, security, and usability.\n\n- Normal images are full-featured and ideal for development.\n- Slim images reduce size by removing unnecessary tools.\n- Alpine is ultra-lightweight with just the essentials.\n- Distroless is the most secure, stripping away even the shell.\n\nWe also include example commands and file comparisons so you can test them yourself. Choosing the right image helps you build faster, safer, and smaller containers.\n\n## ✍️ Written by Muhammad Ishaq\n\n## 📌 Follow me for more:......\n- [GitHub](https://github.com/muhammadiishaq)  \n- [LinkedIn](https://www.linkedin.com/in/muhammadishaq-khan/)\n- [Mediam](https://medium.com/@muhammadishaqpak801)","src/content/post/Docker images-type.md","d9c40652676943ff",{html:274,metadata:275},"<img src=\"/assets/images/posts/Docker images-type.webp\" alt=\"logo\" width=\"800\">\n<h2 id=\"when-building-docker-containers-the-image-you-choose-makes-a-huge-difference-not-just-in-size-but-also-in-security-speed-and-how-easy-it-is-to-manage-your-app\">When building Docker containers, the image you choose makes a huge difference not just in size, but also in security, speed, and how easy it is to manage your app.</h2>\n<h3 id=\"in-this-article-well-break-down-the-4-most-common-docker-image-types\">In this article, we’ll break down the 4 most common Docker image types:</h3>\n<p>1: Normal\n2: Slim\n3: Alpine\n4: Distroless</p>\n<p>You will also get real commands, size comparisons, and tips on when to use each one.</p>\n<h2 id=\"what-is-a-docker-image-lets-recap\">What Is a Docker Image? (Lets Recap)…..🚢</h2>\n<p>Think of a Docker image like a mini-computer. It has an operating system, tools, and your app inside. But just like real computers, some images are heavy and full-featured, while others are small and secure.</p>\n<h2 id=\"️-1-normal-images--the-full-package-means-full-os\">🏋️ 1. Normal Images — The Full Package Means Full OS..</h2>\n<ul>\n<li>Size: 800 MB to 2 GB+</li>\n<li>Shell Access: Yes</li>\n<li>Good for: Development, debugging, and full control</li>\n</ul>\n<p>Normal images come with everything — a full OS (like Ubuntu or Debian), package managers, compilers, and debugging tools.</p>\n<h2 id=\"-use-when\">✅ Use when:</h2>\n<ul>\n<li>You’re actively building or debugging</li>\n<li>You need access to the terminal or tools like curl, vim, gcc, etc.</li>\n</ul>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Pull the slim image</span></span>\n<span class=\"line\"><span>docker pull python:3.9-slim</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># see size of images</span></span>\n<span class=\"line\"><span>docker images</span></span>\n<span class=\"line\"><span># Run container and open shell</span></span>\n<span class=\"line\"><span>docker run -it python:3.9-slim bash</span></span>\n<span class=\"line\"><span># Inside container see files and compare with other images</span></span>\n<span class=\"line\"><span>cd /bin</span></span></code></pre>\n<h2 id=\"-2-slim-images--lighter-but-still-flexible\">🧪 2. Slim Images — Lighter but Still Flexible..</h2>\n<ul>\n<li>Size: Around 400–900 MB</li>\n<li>Shell Access: Yes</li>\n<li>Good for: Smaller builds, test environments\nSlim images are lighter versions of normal ones. They remove unnecessary tools (like build dependencies), but still give you shell access and some debugging features.</li>\n</ul>\n<h2 id=\"-use-when-1\">✅ Use when:</h2>\n<p>You want smaller images but still need a shell\nYou’re testing or doing light development</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Pull the slim image</span></span>\n<span class=\"line\"><span>docker pull python:3.9-slim</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># see size of images</span></span>\n<span class=\"line\"><span>docker images</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Run container and open shell</span></span>\n<span class=\"line\"><span>docker run -it python:3.9-slim bash</span></span>\n<span class=\"line\"><span># Inside container see files and compare with other images</span></span>\n<span class=\"line\"><span>cd /bin</span></span>\n<span class=\"line\"><span>ls</span></span></code></pre>\n<h2 id=\"-3-alpine-images--super-lightweight\">🏃 3. Alpine Images — Super Lightweight</h2>\n<ul>\n<li>Size: ~5 MB</li>\n<li>Shell Access: Yes (BusyBox)</li>\n<li>Good for: Lightweight apps, microservices\nAlpine is a tiny Linux distribution designed for containers. It has a shell and package manager (apk), but not much else.</li>\n</ul>\n<h2 id=\"-use-when-2\">✅ Use when:</h2>\n<p>You care a lot about size and speed\nYour app doesn’t need a lot of OS tools</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Pull the slim image</span></span>\n<span class=\"line\"><span>docker pull alpine</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># see size of images</span></span>\n<span class=\"line\"><span>docker images alpine</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Run container and open shell</span></span>\n<span class=\"line\"><span>docker run -it alpine sh</span></span>\n<span class=\"line\"><span># Inside container see files and compare with other images</span></span>\n<span class=\"line\"><span>cd /bin</span></span>\n<span class=\"line\"><span>ls</span></span></code></pre>\n<h2 id=\"️-4-distroless-images--ultra-secure--minimal\">🛡️ 4. Distroless Images — Ultra Secure &#x26; Minimal</h2>\n<ul>\n<li>Size: ~2–20 MB</li>\n<li>Shell Access: ❌ No</li>\n<li>Good for: Production only (no debugging)\nDistroless images are the most secure and smallest. They do not include a shell, package manager, or OS tools — only your app and runtime.</li>\n</ul>\n<h2 id=\"-use-when-3\">✅ Use when:</h2>\n<p>You’re deploying to production\nYou want maximum security and minimal size</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Pull the slim image</span></span>\n<span class=\"line\"><span>docker pull gcr.io/distroless/base</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># see size of images</span></span>\n<span class=\"line\"><span>docker images gcr.io/distroless/base</span></span></code></pre>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span># Run container and no shell give you error </span></span>\n<span class=\"line\"><span>docker run -it gcr.io/distroless/base  # error</span></span></code></pre>\n<h2 id=\"-summary\">📝 Summary</h2>\n<p>This guide explains the four main types of Docker base images — Normal, Slim, Alpine, and Distroless — and how they impact image size, security, and usability.</p>\n<ul>\n<li>Normal images are full-featured and ideal for development.</li>\n<li>Slim images reduce size by removing unnecessary tools.</li>\n<li>Alpine is ultra-lightweight with just the essentials.</li>\n<li>Distroless is the most secure, stripping away even the shell.</li>\n</ul>\n<p>We also include example commands and file comparisons so you can test them yourself. Choosing the right image helps you build faster, safer, and smaller containers.</p>\n<h2 id=\"️-written-by-muhammad-ishaq\">✍️ Written by Muhammad Ishaq</h2>\n<h2 id=\"-follow-me-for-more\">📌 Follow me for more:…</h2>\n<ul>\n<li><a href=\"https://github.com/muhammadiishaq\">GitHub</a></li>\n<li><a href=\"https://www.linkedin.com/in/muhammadishaq-khan/\">LinkedIn</a></li>\n<li><a href=\"https://medium.com/@muhammadishaqpak801\">Mediam</a></li>\n</ul>",{headings:276,localImagePaths:316,remoteImagePaths:317,frontmatter:318,imagePaths:322},[277,280,283,286,289,292,295,297,300,302,305,307,310,313],{depth:218,slug:278,text:279},"when-building-docker-containers-the-image-you-choose-makes-a-huge-difference-not-just-in-size-but-also-in-security-speed-and-how-easy-it-is-to-manage-your-app","When building Docker containers, the image you choose makes a huge difference not just in size, but also in security, speed, and how easy it is to manage your app.",{depth:25,slug:281,text:282},"in-this-article-well-break-down-the-4-most-common-docker-image-types","In this article, we’ll break down the 4 most common Docker image types:",{depth:218,slug:284,text:285},"what-is-a-docker-image-lets-recap","What Is a Docker Image? (Lets Recap)…..🚢",{depth:218,slug:287,text:288},"️-1-normal-images--the-full-package-means-full-os","🏋️ 1. Normal Images — The Full Package Means Full OS..",{depth:218,slug:290,text:291},"-use-when","✅ Use when:",{depth:218,slug:293,text:294},"-2-slim-images--lighter-but-still-flexible","🧪 2. Slim Images — Lighter but Still Flexible..",{depth:218,slug:296,text:291},"-use-when-1",{depth:218,slug:298,text:299},"-3-alpine-images--super-lightweight","🏃 3. Alpine Images — Super Lightweight",{depth:218,slug:301,text:291},"-use-when-2",{depth:218,slug:303,text:304},"️-4-distroless-images--ultra-secure--minimal","🛡️ 4. Distroless Images — Ultra Secure & Minimal",{depth:218,slug:306,text:291},"-use-when-3",{depth:218,slug:308,text:309},"-summary","📝 Summary",{depth:218,slug:311,text:312},"️-written-by-muhammad-ishaq","✍️ Written by Muhammad Ishaq",{depth:218,slug:314,text:315},"-follow-me-for-more","📌 Follow me for more:…",[],[],{title:267,description:268,date:319,dateFormatted:269,tags:320,coverImage:259,lastUpdated:321,status:200,author:261},["Date","2025-09-09T00:00:00.000Z"],[194,197,256,193,257,195,258],["Date","2025-09-24T01:06:00.000Z"],[],"Docker images-type.md"];

export { _astro_dataLayerContent as default };
